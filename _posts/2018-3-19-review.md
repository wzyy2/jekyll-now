---
layout: post
title: 复习知识
category: [personal]
tag: [CN]
---

在Rockchip这两年，感觉Embedded的东西都被我搞的差不多了，特没意思。。。（逃  

所以最近跳槽换了个工作，主要为自动驾驶平台写应用程序，之所以转到这个方向，是因为觉得之前在底层（Kernel和硬件驱动），GNU/Linux系统的相关经验能在这里起到很大帮助。

新的工作是开发类似ROS一类的应用。考虑到自己自从大学毕业后，很久没有系统的写过C++，甚至OOP编程也没怎么写，所以决定在这个离职到入职的一个月里，再复习下上学时候的软工知识。


# 《深入理解C++11》

#### constexpr

相比const，constexpr可以让赋值在编译时被确定，从而能把该变量保存的ROM里。以前上学的时候用C++写OS的时候，有用到这个，不过写应用软件应该不会接触这个了。


# 《More Effective+C++》

# 《Head First设计模式》

面向对象的核心特性包括封装、继承和多态。  
面向对象编程一定程度上是借鉴现实世界中物体与物体之间的联系，将有特定功能或者说有内在联系的代码抽象成一个类，使代码更容易被理解，更容易被重用。

设计模式的目的：抵御变化，达成复用。

#### 观察者模式
一个目标物件管理所有相依于它的观察者物件，并且在它本身的状态改变时主动发出通知。他定义了一对多的关系。

![](http://img.blog.csdn.net/20170217154500223?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGVuZ3hpYW8xOTkz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

例子：weather和气象站。

#### 工厂模式
在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。

![](http://www.runoob.com/wp-content/uploads/2014/08/factory_pattern_uml_diagram.jpg)

优点： 1、一个调用者想创建一个对象，只要知道其名称就可以了。 2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 3、屏蔽产品的具体实现，调用者只关心产品的接口。

缺点：每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。

#### 策略模式
策略模式定义了一系列的算法，并将每一个算法封装起来，而且使他们可以相互替换，让算法独立于使用它的客户而独立变化。

![](http://img.blog.csdn.net/20170410234139991?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjEyNDQzOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)




# 《算法导论》

这个和工作无关，只是为了以后再跳槽的可能要用。

面Embedded的工作的时候，基本上其实也不会涉及算法，最多写个简单的软件过程而已。

但是面一般软开的时候，因为缺少相关经验，因为都会让我做题。。。  
因此，我也错过了Nvidia和百度的机会。


# 《深入理解linux内核》

和工作无关。。。只是以后Kernel Level的工作估计很少做了，再看看，巩固下知识。

#### 进程

task_struct 进程描述符， thread_info指向task_struct，放在栈的最下面。
![](http://img.blog.csdn.net/20160512131035840)

parent的pid是其他的tgid，同样一个tgid的算一个进程组。

线程一般是进程允许共享页表，打开文件表，信号处理。

Linux内核在创建进程的时候，是写时复制，只有写新物理页的时候，才会拷贝一个新的。（内核只为新生成的子进程创建虚拟空间结构，它们来复制于父进程的虚拟究竟结构，但是不为这些段分配物理内存，它们共享父进程的物理空间，当父子进程中有更改相应段的行为发生时，再为子进程相应的段分配物理空间）

vfork不会复制页表项，因此父进程必须等子退出才行，vfork的程序一般会另外调用exec，创建自己的页表，不需要复制主的。

进程僵死，是因为需要通知父进程，不能马上就删除进程描述符这些资源

#### 中断

软中断和tasklet是中断上下文，但是是中断下半部。tasklet是一种软中断，一般用在IO上。
![](http://blog.chinaunix.net/attachment/201202/21/23769728_1329841791vgD6.png)

fault可以修复，trap没有影响，一般只是为了debug，abort会终止进程。中断描述符存放入口。

在中断禁止过程中丢失的中断（比如说do_IRQ, 在do_IRQ被调用时，处理器已经屏蔽了对外部中断的响应）（为了支持中断的嵌套执行，Linux内核在进入中断服务程序之前会将硬中断开启，运行完中断服务程序之后再将硬中断关闭，在这期间硬件中断是可以被抢占的），在irq_enable的时候，会通过内核代码检查一次，手动触发。

linux支持中断嵌套，一个中断可以抢占其他中断和异常，不过异常不能抢占中断，一般来说内核里的异常就缺页，中断处理函数不会触发缺页。

IRQF_ONESHOT保护，只有中断下半部分threaded_handler执行完才行。（这是因为在旧的中断处理机制中，top half是不可重入的，强制线程化之后，强制设定IRQF_ONESHOT可以保证threaded handler是不会重入的）（在那些被强制线程化的中断线程中，disable bottom half的处理。这是因为在旧的中断处理机制中，botton half是不可能抢占top half的执行，强制线程化之后，应该保持这一点）


#### 内核同步

一个tasklet，softirq不会在不同CPU上执行，可以减少同步问题。

每CPU变量都需要禁止抢占才能访问，避免其他CPU访问到了。

内存屏障既用于多处理器系统（MP），也用于单处理器系统（UP），api前面带smp，都是用于多处理器的。

spin_lock会禁止抢占，但是只有在lock住后才禁止抢占，如果是在忙等，还是会被抢占的。
rw_lock读写自旋锁。
seqlock顺序锁，类似读写自旋锁，但是允许读的时候写。

RCU是为了保护被多个CPU读的数据而设计的结构，允许多个读者和写者（rwlock只允许一个写），另外rcu不使用ALL CPU的变量，效率高。  
读者不需要获得任何锁就可以访问它，但写者在访问它时首先拷贝一个副本，然后对副本进行修改，最后使用一个回调（callback）机制在适当的时机把指向原来数据的指针重新指向新的被修改的数据。  （为写指针地址是一个原子操作）（而这个“适当的时机”就是所有CPU经历了一次进程切换（也就是一个grace period）。为什么这么设计？因为RCU读者的实现就是关抢占执行读取，读完了当然就可以进程切换了，也就等于是写者可以操作临界区了。）（RCU允许多个读者同时访问被保护的数据，也允许多个读者在有写者时访问被保护的数据）
RCU会关抢占，不能在临界区睡眠。  
http://blog.jobbole.com/106856/


#### 定时

clocksource（clocksource不能被编程，没有产生事件的能力，它主要被用于timekeeper来实现对真实时间进行精确的统计）：http://www.wowotech.net/timer_subsystem/clocksource.html  
clockevent(触发中断的) ： http://www.wowotech.net/timer_subsystem/clock-event.html  
timekeeper: http://blog.csdn.net/DroidPhone/article/details/7989566  
arm-timer(注意armtimer一般依赖一个system counter，在rk平台上都会有一个timer做system counter给arch timer（clocksource）做源，同时注册成了clockevent设备): http://www.wowotech.net/timer_subsystem/armgeneraltimer.html  

![](http://img.my.csdn.net/uploads/201209/25/1348564183_8324.png)

jiffies记录系统节拍。

动态定时器通过软件实现，没有限制。

#### 调度

linux调度基于分时，cpu时间被分成slice。


# 面试常见问题
